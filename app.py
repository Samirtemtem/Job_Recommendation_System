from flask import Flask, request, render_template, jsonify, session, redirect, url_for
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import pickle
from pymongo import MongoClient
import logging
import re
from bson import ObjectId
import os
from datetime import datetime, timedelta
from flask_cors import CORS
import json

app = Flask(__name__)
app.secret_key = 'job_recommendation_system_secret_key'  # Required for session
CORS(app)  # Enable CORS for all routes

# Set up logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# MongoDB setup
client = MongoClient('mongodb+srv://root:root@cluster0.wa1te.mongodb.net/recruitpro?retryWrites=true&w=majority')
db = client['recruitpro']  # Replace with your actual database name if different
recommendations_collection = db['jobRecommendations']  # New collection for recommendations

# Collections
users_collection = db['users']
profiles_collection = db['profiles']
jobposts_collection = db['jobposts']
skills_collection = db['skills']
educations_collection = db['educations']
experiences_collection = db['experiences']

logging.info("Loading data from MongoDB collections for Flask app...")

# Load data directly if needed for real-time updates
# Otherwise, we'll use the pickle files generated by main.py
try:
    with open('similarity_matrix.pkl', 'rb') as f:
        similarity_matrix = pickle.load(f)

    with open('candidate_similarity_matrix.pkl', 'rb') as f:
        candidate_similarity_matrix = pickle.load(f)

    with open('label_encoders.pkl', 'rb') as f:
        label_encoders = pickle.load(f)

    with open('jobposts.pkl', 'rb') as f:
        jobposts = pickle.load(f)

    with open('candidates.pkl', 'rb') as f:
        candidates = pickle.load(f)
    
    # Load the detailed matching information
    detailed_matching_info = {}
    try:
        with open('detailed_matching_info.pkl', 'rb') as f:
            detailed_matching_info = pickle.load(f)
        logging.info("Loaded detailed matching information from pickle file")
    except Exception as e:
        logging.warning(f"Could not load detailed matching information: {e}")
        logging.warning("Will calculate matching information on the fly")
        
    logging.info("Successfully loaded data from pickle files")
    logging.info(f"Loaded {len(candidates)} candidates and {len(jobposts)} job posts")
    
    # Extract all unique skills for semantic matching
    all_skills = []
    for skills_list in candidates['Skills'].tolist() + jobposts['Skills'].tolist():
        if isinstance(skills_list, list):
            all_skills.extend(skills_list)
    all_skills = list(set(all_skills))
    logging.info(f"Extracted {len(all_skills)} unique skills from data")
    
    # Debug log of first few candidates and their IDs
    if not candidates.empty:
        sample_candidates = candidates.head(3)
        logging.debug(f"Sample candidates:\n{sample_candidates}")
        
        # Log the exact CandidateID values and their data types
        logging.debug("CandidateID details:")
        for idx, candidate_id in enumerate(candidates['CandidateID'].head(5)):
            logging.debug(f"  {idx}: {candidate_id} (type: {type(candidate_id)})")
        
except Exception as e:
    logging.error(f"Error loading data from pickle files: {e}")
    # If pickle files aren't available, we could reload from MongoDB here
    # This is a fallback and would require reimplementing the logic from main.py
    all_skills = []
    detailed_matching_info = {}

# Helper function to normalize ID format
def normalize_id(id_value):
    if id_value is None:
        return None
    return str(id_value).strip()

# Helper function to find candidate by ID with fuzzy matching
def find_candidate_by_id(candidate_id, candidates_df):
    """Find a candidate with exact or partial ID match"""
    # Try exact match first
    exact_matches = candidates_df[candidates_df['CandidateID'] == candidate_id]
    if not exact_matches.empty:
        return exact_matches.index[0], 'exact'
    
    # Convert to string for string operations
    candidate_id_str = str(candidate_id).strip()
    
    # Try ObjectId matching if it looks like an ObjectId
    if re.match(r'^[0-9a-f]{24}$', candidate_id_str):
        # Match against the string representation of ObjectId
        for idx, cid in enumerate(candidates_df['CandidateID']):
            if str(cid).strip() == candidate_id_str:
                return idx, 'objectid_string'
    
    # Try partial match (contained within)
    for idx, cid in enumerate(candidates_df['CandidateID']):
        if candidate_id_str in str(cid):
            return idx, 'partial'
    
    # Try prefix match (starts with)
    for idx, cid in enumerate(candidates_df['CandidateID']):
        if str(cid).startswith(candidate_id_str):
            return idx, 'prefix'
    
    # No match found
    return None, 'no_match'

def hybrid_recommendation(candidate_id, candidates, jobposts, similarity_matrix, candidate_similarity_matrix):
    try:
        # Normalize the candidate ID
        normalized_id = normalize_id(candidate_id)
        logging.debug(f"Searching for candidate with normalized ID: {normalized_id}")
        
        # Try direct index lookup first
        try:
            candidate_idx = candidates[candidates['CandidateID'] == normalized_id].index[0]
            match_type = 'exact'
        except IndexError:
            # If direct lookup fails, try fuzzy matching
            candidate_idx, match_type = find_candidate_by_id(normalized_id, candidates)
            if candidate_idx is None:
                raise IndexError(f"No candidate found with ID {normalized_id} (tried exact, ObjectId, partial, and prefix matching)")
        
        logging.debug(f"Found candidate at index {candidate_idx} using {match_type} matching")
        logging.debug(f"Candidate details: {candidates.iloc[candidate_idx][['CandidateID', 'firstName', 'lastName']] if 'firstName' in candidates.columns else candidates.iloc[candidate_idx]['CandidateID']}")

        # Get top 5 job recommendations
        job_indices = np.argsort(-similarity_matrix[:, candidate_idx])[:5]
        logging.debug(f"Job indices: {job_indices}")
        
        # Debug raw similarity values
        similarity_values = similarity_matrix[:, candidate_idx]
        logging.debug(f"All similarity values for this candidate: min={np.min(similarity_values)}, max={np.max(similarity_values)}, mean={np.mean(similarity_values)}")
        logging.debug(f"Top 5 similarity values: {similarity_values[job_indices]}")
        
        # Create content-based recommendations dataframe
        content_based = jobposts.iloc[job_indices].copy()
        content_based['Similarity'] = similarity_matrix[job_indices, candidate_idx]
        
        # Log a more readable version of the recommendations with percentages
        recommendations_log = content_based.copy()
        recommendations_log['Match Percentage'] = recommendations_log['Similarity'].apply(lambda x: f"{x*100:.2f}%")
        logging.debug(f"Content-based jobs with percentages: \n{recommendations_log[['JobTitle', 'Match Percentage']]}")

        # Job recommendation for other candidates (similar to this candidate)
        # Using the first recommended job
        if len(job_indices) > 0:
            job_id = jobposts.iloc[job_indices[0]]['JobID'] 
            job_idx = jobposts[jobposts['JobID'] == job_id].index[0]
            
            # Find similar candidates for this job
            candidate_indices = np.argsort(-candidate_similarity_matrix[:, job_idx])[:5]
            similar_candidates = candidates.iloc[candidate_indices].copy()
            similar_candidates['Similarity'] = candidate_similarity_matrix[candidate_indices, job_idx]
            
            # Log similar candidates with percentages
            similar_candidates_log = similar_candidates.copy()
            similar_candidates_log['Match Percentage'] = similar_candidates_log['Similarity'].apply(lambda x: f"{x*100:.2f}%")
            logging.debug(f"Similar candidates with percentages: \n{similar_candidates_log[['CandidateID', 'Match Percentage']]}")
        else:
            similar_candidates = pd.DataFrame(columns=['CandidateID', 'Similarity'])
        
        return (
            content_based.sort_values(by='Similarity', ascending=False).reset_index(drop=True),
            similar_candidates.sort_values(by='Similarity', ascending=False).reset_index(drop=True)
        )
    except IndexError as e:
        logging.error(f"No candidate found with ID {candidate_id}. Error: {e}")
        return pd.DataFrame(columns=['JobID', 'JobTitle', 'Similarity']), pd.DataFrame(columns=['CandidateID', 'Similarity'])
    except Exception as e:
        logging.error(f"Error in recommendation: {e}")
        return pd.DataFrame(columns=['JobID', 'JobTitle', 'Similarity']), pd.DataFrame(columns=['CandidateID', 'Similarity'])

@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')

@app.route('/recommend', methods=['POST'])
def recommend_jobs():
    candidate_id = request.form['candidate_id']
    logging.debug("Received request for candidate ID: %s", candidate_id)
    
    try:
        recommended_jobs, similar_candidates = hybrid_recommendation(
            candidate_id, candidates, jobposts, similarity_matrix, candidate_similarity_matrix
        )
        logging.debug("Recommended jobs: \n%s", recommended_jobs)
        logging.debug("Similar candidates: \n%s", similar_candidates)
        
        # Find the actual candidate data for additional processing
        candidate_idx = None
        for idx, row in candidates.iterrows():
            if str(row['CandidateID']) == str(candidate_id):
                candidate_idx = idx
                break
        
        # If we found the candidate, prepare detailed match information
        if candidate_idx is not None:
            candidate_data = candidates.iloc[candidate_idx]
            candidate_id_str = str(candidate_data['CandidateID'])
            
            # Store candidate skills for matching in the template
            candidate_skills = candidate_data['Skills'] if isinstance(candidate_data['Skills'], list) else []
            
            # Store experience and education text
            experience_text = ""
            if 'experience_details' in candidate_data and isinstance(candidate_data['experience_details'], list):
                experience_text = " ".join([str(exp) for exp in candidate_data['experience_details']])
            
            education_text = ""
            if 'Education' in candidate_data and isinstance(candidate_data['Education'], list):
                education_text = " ".join([str(edu) for edu in candidate_data['Education']])
            
            # Create semantic skills list
            candidate_semantic_skills = []
            for skill in candidate_skills:
                    if not isinstance(skill, str):
                        continue
                    skill_lower = skill.lower()
                    for s in all_skills:
                        if (len(s) > 3 and (s.lower() in skill_lower or skill_lower in s.lower()) and 
                            s not in candidate_skills and s not in candidate_semantic_skills):
                            candidate_semantic_skills.append(s)
            
            # Store these in the session for the template
            session['candidate_id'] = candidate_id_str
            session['candidate_skills'] = candidate_skills
            session['candidate_semantic_skills'] = candidate_semantic_skills
            session['experience_text'] = experience_text
            session['education_text'] = education_text
            
            # Prepare detailed match information for each job
            matching_details = []
            for i, job in recommended_jobs.iterrows():
                job_id_str = str(job['JobID'])
                job_details = {
                    'job_id': job_id_str,
                    'job_title': job['JobTitle'],
                    'skills_score': 0.0,
                    'experience_score': 0.0,
                    'education_score': 0.0,
                    'total_score': job['Similarity'],
                    'exact_skill_matches': [],
                    'semantic_skill_matches': [],
                    'experience_matching_words': [],
                    'education_matching_words': [],
                    'semantic_education_matches': [],
                    'semantic_experience_matches': [],
                    'job_text': job['JobDescription'] if 'JobDescription' in job else "",
                    'experience_text': experience_text,
                    'education_text': education_text
                }
                
                # If we have detailed matching info from the pickle file, use it
                if job_id_str in detailed_matching_info and candidate_id_str in detailed_matching_info[job_id_str]:
                    detailed_info = detailed_matching_info[job_id_str][candidate_id_str]
                    
                    # Extract component scores
                    job_details['skills_score'] = detailed_info.get('skill_similarity', 0.0)
                    job_details['experience_score'] = detailed_info.get('experience_similarity', 0.0)
                    job_details['education_score'] = detailed_info.get('education_similarity', 0.0)
                    
                    # Extract matched skills
                    job_details['exact_skill_matches'] = detailed_info.get('exact_skill_matches', [])
                    job_details['semantic_skill_matches'] = detailed_info.get('semantic_skill_matches', [])
                    
                    # Extract matching words
                    job_details['experience_matching_words'] = [word for word, score in detailed_info.get('experience_matching_words', [])]
                    job_details['education_matching_words'] = [word for word, score in detailed_info.get('education_matching_words', [])]
                    
                    # Extract semantic education and experience matches
                    job_details['semantic_education_matches'] = detailed_info.get('semantic_education_matches', [])
                    job_details['semantic_experience_matches'] = detailed_info.get('semantic_experience_matches', [])
                else:
                    # Calculate on the fly if detailed info is not available
                    logging.info(f"Detailed matching info not found for job {job_id_str} and candidate {candidate_id_str}")
                    
                    # Fallback: calculate scores
                    job_details['skills_score'] = job['Similarity'] * 0.5  # Estimate 50% from skills
                    job_details['experience_score'] = job['Similarity'] * 0.3  # Estimate 30% from experience
                    job_details['education_score'] = job['Similarity'] * 0.2  # Estimate 20% from education
                    
                    # Identify exact skill matches
                    job_skills = job['Skills'] if isinstance(job['Skills'], list) else []
                    job_details['exact_skill_matches'] = [skill for skill in job_skills if skill in candidate_skills]
                    
                    # Simple matching word extraction (less accurate than in main.py)
                    if 'JobDescription' in job and pd.notna(job['JobDescription']):
                        # Extract experience matching words
                        job_desc_words = set(re.findall(r'\b\w{4,}\b', job['JobDescription'].lower()))
                        exp_words = set(re.findall(r'\b\w{4,}\b', experience_text.lower()))
                        edu_words = set(re.findall(r'\b\w{4,}\b', education_text.lower()))
                        
                        job_details['experience_matching_words'] = list(job_desc_words.intersection(exp_words))
                        job_details['education_matching_words'] = list(job_desc_words.intersection(edu_words))
                        
                        # Simple fallback for semantic matches
                        job_details['semantic_education_matches'] = []
                        job_details['semantic_experience_matches'] = []
                
                # Store the complete details
                matching_details.append(job_details)
                
                # Update the DataFrame with component scores
                recommended_jobs.at[i, 'SkillsScore'] = job_details['skills_score']
                recommended_jobs.at[i, 'ExperienceScore'] = job_details['experience_score']
                recommended_jobs.at[i, 'EducationScore'] = job_details['education_score']
            
            # Store the matching details in the session for the template
            session['matching_details'] = matching_details
        
        return render_template(
            'recommendations.html', 
            jobs=recommended_jobs, 
            candidates=similar_candidates,
            matching_details=session.get('matching_details', [])
        )
    except Exception as e:
        logging.error(f"Error generating recommendations: {e}")
        return render_template(
            'error.html', 
            error_message=f"Could not generate recommendations: {str(e)}"
        )

# New debug route to display all candidates
@app.route('/debug/candidates', methods=['GET'])
def debug_candidates():
    try:
        # Get all columns for complete debugging
        if candidates.empty:
            return "No candidates found in the database."
        
        # Format the Skills column to be more readable
        candidates_display = candidates.copy()
        if 'Skills' in candidates.columns:
            candidates_display['Skills'] = candidates_display['Skills'].apply(
                lambda skills: ", ".join(skills) if isinstance(skills, list) else str(skills)
            )
        
        # Format IDs to ensure they are displayed correctly
        candidates_display['CandidateID_str'] = candidates_display['CandidateID'].apply(lambda x: str(x))
        
        # Get the ID being searched for from the query parameter
        search_id = request.args.get('id', '')
        
        # If a search ID is provided, highlight matching rows
        if search_id:
            search_results = []
            for idx, row in candidates_display.iterrows():
                candidate_id = str(row['CandidateID'])
                match_type = None
                
                if candidate_id == search_id:
                    match_type = 'exact match'
                elif search_id in candidate_id:
                    match_type = 'partial match'
                elif candidate_id.startswith(search_id):
                    match_type = 'prefix match'
                
                if match_type:
                    search_results.append({
                        'index': idx,
                        'candidate_id': candidate_id,
                        'match_type': match_type,
                        'data': {col: row[col] for col in candidates_display.columns if col != 'CandidateID_str'}
                    })
            
            if search_results:
                search_html = f"<h2>Search Results for ID: {search_id}</h2>"
                for result in search_results:
                    search_html += f"""
                    <div class="card mb-3">
                        <div class="card-header">
                            <strong>Index {result['index']}</strong> - {result['match_type']}
                        </div>
                        <div class="card-body">
                            <p><strong>CandidateID:</strong> {result['candidate_id']}</p>
                            <table class="table table-sm">
                                <tbody>
                    """
                    for key, value in result['data'].items():
                        search_html += f"<tr><td>{key}</td><td>{value}</td></tr>"
                    
                    search_html += "</tbody></table></div></div>"
            else:
                search_html = f"<div class='alert alert-warning'>No matches found for ID: {search_id}</div>"
        else:
            search_html = ""
        
        # Display the first 50 candidates by default for performance
        display_limit = 50
        limited_display = candidates_display.head(display_limit)
        candidates_html = limited_display.to_html(classes='table table-striped table-bordered', index=True)
        
        # Search form for specific ID
        search_form = f"""
        <form method="get" action="/debug/candidates" class="mb-4">
            <div class="input-group">
                <input type="text" name="id" class="form-control" placeholder="Search for candidate ID" value="{search_id}">
                <div class="input-group-append">
                    <button class="btn btn-primary" type="submit">Search</button>
                </div>
            </div>
        </form>
        """
        
        # Create a simple HTML page to display the data
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Candidates Debug</title>
            <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
            <style>
                body {{ padding: 20px; }}
                h1, h2 {{ margin-bottom: 20px; }}
                .container {{ max-width: 100%; }}
                .table {{ margin-top: 20px; font-size: 0.9rem; }}
                .highlight {{ background-color: #ffffcc; }}
                .card {{ margin-bottom: 20px; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>All Candidates (Total: {len(candidates)})</h1>
                <div class="d-flex mb-3">
                    <a href="/" class="btn btn-primary mr-2">Back to Home</a>
                    <a href="/debug/jobposts" class="btn btn-secondary">View Job Posts</a>
                </div>
                
                {search_form}
                
                {search_html}
                
                <h2>Candidate Data (first {display_limit} records)</h2>
                <div class="alert alert-info">
                    <p><strong>Note:</strong> Only showing the first {display_limit} records for performance. Use the search above to find specific candidates.</p>
                </div>
                <div class="table-responsive">
                    {candidates_html}
                </div>
            </div>
        </body>
        </html>
        """
        return html
    except Exception as e:
        return f"Error displaying candidates: {str(e)}"

# Debug route to display all job posts
@app.route('/debug/jobposts', methods=['GET'])
def debug_jobposts():
    try:
        # Get all columns for complete debugging
        if jobposts.empty:
            return "No job posts found in the database."
        
        # Format the Skills column to be more readable
        jobposts_display = jobposts.copy()
        if 'Skills' in jobposts.columns:
            jobposts_display['Skills'] = jobposts_display['Skills'].apply(
                lambda skills: ", ".join(skills) if isinstance(skills, list) else str(skills)
            )
        
        # Display the first 50 jobposts by default for performance
        display_limit = 50
        limited_display = jobposts_display.head(display_limit)
        jobposts_html = limited_display.to_html(classes='table table-striped table-bordered', index=True)
        
        # Create a simple HTML page to display the data
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Job Posts Debug</title>
            <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
            <style>
                body {{ padding: 20px; }}
                h1 {{ margin-bottom: 20px; }}
                .container {{ max-width: 100%; }}
                .table {{ margin-top: 20px; font-size: 0.9rem; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>All Job Posts (Total: {len(jobposts)})</h1>
                <div class="d-flex mb-3">
                    <a href="/" class="btn btn-primary mr-2">Back to Home</a>
                    <a href="/debug/candidates" class="btn btn-secondary">View Candidates</a>
                </div>
                <div class="alert alert-info">
                    <p><strong>Note:</strong> Only showing the first {display_limit} records for performance.</p>
                </div>
                <div class="table-responsive">
                    {jobposts_html}
                </div>
            </div>
        </body>
        </html>
        """
        return html
    except Exception as e:
        return f"Error displaying job posts: {str(e)}"

# Add a new route to analyze skill overlap
@app.route('/debug/skill_analysis', methods=['GET'])
def debug_skill_analysis():
    try:
        if candidates.empty or jobposts.empty:
            return "No data available for skill analysis."
        
        # Extract unique skills from candidates and job posts
        candidate_skills = set()
        for skills in candidates['Skills']:
            if isinstance(skills, list):
                candidate_skills.update(skills)

        jobpost_skills = set()
        for skills in jobposts['Skills']:
            if isinstance(skills, list):
                jobpost_skills.update(skills)
        
        # Find common skills and unique skills
        common_skills = candidate_skills.intersection(jobpost_skills)
        only_in_candidates = candidate_skills - jobpost_skills
        only_in_jobs = jobpost_skills - candidate_skills
        
        # Count skills per candidate and job
        candidate_skill_counts = []
        for i, row in candidates.iterrows():
            skills = row['Skills'] if isinstance(row['Skills'], list) else []
            candidate_skill_counts.append({
                'candidate_id': row['CandidateID'],
                'name': f"{row['firstName']} {row['lastName']}" if 'firstName' in row else str(row['CandidateID']),
                'skill_count': len(skills),
                'skills': ', '.join(skills) if skills else 'None'
            })
        
        job_skill_counts = []
        for i, row in jobposts.iterrows():
            skills = row['Skills'] if isinstance(row['Skills'], list) else []
            job_skill_counts.append({
                'job_id': row['JobID'],
                'title': row['JobTitle'],
                'skill_count': len(skills),
                'skills': ', '.join(skills) if skills else 'None'
            })
        
        # Create HTML for the analysis
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Skill Analysis</title>
            <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
            <style>
                body {{ padding: 20px; }}
                h1, h2, h3 {{ margin-bottom: 20px; }}
                .container {{ max-width: 100%; }}
                .skill-tag {{
                    background-color: #e7f4fd;
                    color: #3498db;
                    padding: 5px 10px;
                    border-radius: 4px;
                    margin-right: 5px;
                    margin-bottom: 5px;
                    display: inline-block;
                }}
                .common-skill {{
                    background-color: #d4edda;
                    color: #155724;
                }}
                .candidate-only-skill {{
                    background-color: #fff3cd;
                    color: #856404;
                }}
                .job-only-skill {{
                    background-color: #f8d7da;
                    color: #721c24;
                }}
                .skill-section {{
                    margin-bottom: 30px;
                    padding: 15px;
                    border-radius: 5px;
                    background-color: #f8f9fa;
                }}
                .table {{ margin-top: 20px; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Skill Analysis</h1>
                <div class="d-flex mb-3">
                    <a href="/" class="btn btn-primary mr-2">Back to Home</a>
                    <a href="/debug/candidates" class="btn btn-outline-secondary mr-2">View Candidates</a>
                    <a href="/debug/jobposts" class="btn btn-outline-secondary">View Job Posts</a>
                </div>
                
                <div class="alert alert-info">
                    <p><strong>Note:</strong> This page analyzes the skill overlap between candidates and job posts.</p>
                </div>
                
                <div class="row">
                    <div class="col-md-6">
                        <div class="card mb-4">
                            <div class="card-header">
                                <h3 class="m-0">Summary</h3>
                            </div>
                            <div class="card-body">
                                <p><strong>Total candidates:</strong> {len(candidates)}</p>
                                <p><strong>Total job posts:</strong> {len(jobposts)}</p>
                                <p><strong>Total unique candidate skills:</strong> {len(candidate_skills)}</p>
                                <p><strong>Total unique job post skills:</strong> {len(jobpost_skills)}</p>
                                <p><strong>Common skills:</strong> {len(common_skills)}</p>
                                <p><strong>Skills only in candidates:</strong> {len(only_in_candidates)}</p>
                                <p><strong>Skills only in jobs:</strong> {len(only_in_jobs)}</p>
                                <p><strong>Skill overlap percentage:</strong> {len(common_skills)/len(candidate_skills.union(jobpost_skills))*100:.1f}%</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="card mb-4">
                            <div class="card-header">
                                <h3 class="m-0">Skill Distribution</h3>
                            </div>
                            <div class="card-body">
                                <div class="skill-section">
                                    <h4>Common Skills ({len(common_skills)})</h4>
                                    {' '.join([f'<span class="skill-tag common-skill">{skill}</span>' for skill in sorted(common_skills)])}
                                </div>
                                
                                <div class="skill-section">
                                    <h4>Skills Only in Candidates ({len(only_in_candidates)})</h4>
                                    {' '.join([f'<span class="skill-tag candidate-only-skill">{skill}</span>' for skill in sorted(only_in_candidates)])}
                                </div>
                                
                                <div class="skill-section">
                                    <h4>Skills Only in Jobs ({len(only_in_jobs)})</h4>
                                    {' '.join([f'<span class="skill-tag job-only-skill">{skill}</span>' for skill in sorted(only_in_jobs)])}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <div class="col-md-6">
                        <div class="card mb-4">
                            <div class="card-header">
                                <h3 class="m-0">Candidates With Fewest Skills</h3>
                            </div>
                            <div class="card-body">
                                <table class="table table-bordered">
                                    <thead>
                                        <tr>
                                            <th>Candidate</th>
                                            <th>Skill Count</th>
                                            <th>Skills</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {''.join([f'<tr><td>{c["name"]}</td><td>{c["skill_count"]}</td><td>{c["skills"]}</td></tr>' for c in sorted(candidate_skill_counts, key=lambda x: x["skill_count"])[:5]])}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="card mb-4">
                            <div class="card-header">
                                <h3 class="m-0">All Job Posts</h3>
                            </div>
                            <div class="card-body">
                                <table class="table table-bordered">
                                    <thead>
                                        <tr>
                                            <th>Job Title</th>
                                            <th>Skill Count</th>
                                            <th>Skills</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {''.join([f'<tr><td>{j["title"]}</td><td>{j["skill_count"]}</td><td>{j["skills"]}</td></tr>' for j in job_skill_counts])}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card mb-4">
                    <div class="card-header">
                        <h3 class="m-0">Recommendation</h3>
                    </div>
                    <div class="card-body">
                        <div class="alert alert-warning">
                            <p><strong>Issue detected:</strong> Low skill overlap between candidates and jobs.</p>
                            <p>To improve matching quality:</p>
                            <ol>
                                <li>Make sure job postings include the same skill terminology as candidate profiles</li>
                                <li>Ensure candidates have their skills properly populated</li>
                                <li>Consider normalizing skill names (e.g., "JavaScript" vs "Javascript")</li>
                                <li>Add more categorical features to improve matching beyond skills</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>
        </body>
        </html>
        """
        return html
    except Exception as e:
        return f"Error analyzing skills: {str(e)}"

def update_user_recommendations(user_id):
    """Update recommendations for a specific user and store in the database"""
    # Find the candidate in the dataset
    candidate_idx, candidate_data = find_candidate_by_id(user_id, candidates)
    
    if candidate_idx is None:
        return {"error": f"Candidate with ID {user_id} not found"}, 404
    
    # Calculate recommendations
    recommended_jobs, similar_candidates = hybrid_recommendation(
        user_id, candidates, jobposts, similarity_matrix, candidate_similarity_matrix
    )
    
    # Format recommendations for storage
    recommendations = []
    for _, job in recommended_jobs.iterrows():
        job_id = str(job['JobID'])
        match_detail = {}
        
        # Get detailed matching information if available
        if job_id in detailed_matching_info and user_id in detailed_matching_info[job_id]:
            match_detail = detailed_matching_info[job_id][user_id]
        
        # Convert numpy types to Python native types for MongoDB
        recommendations.append({
            'jobId': job_id,
            'jobTitle': job['JobTitle'] if 'JobTitle' in job else '',
            'similarity': float(job['Similarity']),
            'skillScore': float(match_detail.get('skill_similarity', 0)),
            'experienceScore': float(match_detail.get('experience_similarity', 0)),
            'educationScore': float(match_detail.get('education_similarity', 0)),
            'exactSkillMatches': match_detail.get('exact_skill_matches', []),
            'semanticSkillMatches': [
                {'jobSkill': js, 'candidateSkill': cs} 
                for js, cs in match_detail.get('semantic_skill_matches', [])
            ],
            'semanticEducationMatches': [
                {'jobEducation': je, 'candidateEducation': ce} 
                for je, ce in match_detail.get('semantic_education_matches', [])
            ],
            'semanticExperienceMatches': [
                {'jobExperience': je, 'candidateExperience': ce} 
                for je, ce in match_detail.get('semantic_experience_matches', [])
            ],
            'experienceMatches': [
                word[0] for word in match_detail.get('experience_matching_words', [])[:20]
            ],
            'educationMatches': [
                word[0] for word in match_detail.get('education_matching_words', [])[:20]
            ],
            'interacted': False,
            'applied': False,
            'lastViewed': None
        })
    
    # Store in database
    recommendations_collection.update_one(
        {'userId': user_id},
        {
            '$set': {
                'timestamp': datetime.now(),
                'recommendations': recommendations,
                'algorithm': {
                    'version': '1.0',
                    'weights': {'skills': 1/3, 'experience': 1/3, 'education': 1/3}
                }
            }
        },
        upsert=True
    )
    
    return {
        'jobs': recommendations,
        'timestamp': datetime.now()
    }

# REST API Endpoints for Job Recommendations

@app.route('/api/recommendations/jobs', methods=['GET'])
def get_job_recommendations_api():
    """Get job recommendations for a user from the database or calculate new ones"""
    user_id = request.args.get('candidateId')
    
    if not user_id:
        return jsonify({"error": "candidateId parameter is required"}), 400
    
    # First try to get from database
    stored_recommendations = recommendations_collection.find_one({'userId': user_id})
    
    # If recommendations exist and are fresh enough (< 24 hours)
    if stored_recommendations and (datetime.now() - stored_recommendations['timestamp']).total_seconds() < 86400:
        recommendations = stored_recommendations['recommendations']
        
        # Update interaction tracking for viewed recommendations
        recommendations_collection.update_many(
            {'userId': user_id},
            {'$set': {'lastViewed': datetime.now()}}
        )
        
        return jsonify({
            'jobs': recommendations,
            'source': 'database',
            'lastUpdated': stored_recommendations['timestamp']
        })
    
    # Otherwise calculate new recommendations and store them
    result = update_user_recommendations(user_id)
    
    if isinstance(result, tuple) and len(result) == 2 and 'error' in result[0]:
        return jsonify(result[0]), result[1]
    
    return jsonify({
        'jobs': result['jobs'],
        'source': 'fresh_calculation',
        'lastUpdated': result['timestamp']
    })

@app.route('/api/recommendations/refresh', methods=['POST'])
def refresh_recommendations_api():
    """Force refresh recommendations for a user"""
    data = request.get_json()
    user_id = data.get('candidateId')
    
    if not user_id:
        return jsonify({"error": "candidateId parameter is required"}), 400
    
    result = update_user_recommendations(user_id)
    
    if isinstance(result, tuple) and len(result) == 2 and 'error' in result[0]:
        return jsonify(result[0]), result[1]
    
    return jsonify({
        'message': 'Recommendations refreshed successfully',
        'timestamp': result['timestamp'],
        'count': len(result['jobs'])
    })

@app.route('/api/recommendations/interaction', methods=['POST'])
def track_recommendation_interaction():
    """Track user interaction with recommendations"""
    data = request.get_json()
    user_id = data.get('candidateId')
    job_id = data.get('jobId')
    interaction_type = data.get('type')  # 'view', 'click', 'apply'
    
    if not user_id or not job_id or not interaction_type:
        return jsonify({"error": "candidateId, jobId and type parameters are required"}), 400
    
    # Default updates based on interaction type
    update = {'recommendations.$.lastViewed': datetime.now()}
    
    if interaction_type == 'view' or interaction_type == 'click':
        update['recommendations.$.interacted'] = True
    elif interaction_type == 'apply':
        update['recommendations.$.applied'] = True
        update['recommendations.$.interacted'] = True
    
    # Update the specific job recommendation
    result = recommendations_collection.update_one(
        {
            'userId': user_id,
            'recommendations.jobId': job_id
        },
        {'$set': update}
    )
    
    if result.matched_count == 0:
        return jsonify({"error": "Recommendation not found"}), 404
    
    return jsonify({
        'success': True,
        'message': f'Interaction of type {interaction_type} recorded successfully'
    })

@app.route('/api/recommendations/stats', methods=['GET'])
def get_recommendation_stats():
    """Get statistics about recommendations"""
    user_id = request.args.get('candidateId')
    
    if not user_id:
        return jsonify({"error": "candidateId parameter is required"}), 400
    
    stored_recommendations = recommendations_collection.find_one({'userId': user_id})
    
    if not stored_recommendations:
        return jsonify({
            'hasRecommendations': False,
            'message': 'No recommendations found for this user'
        })
    
    recommendations = stored_recommendations['recommendations']
    
    # Calculate stats
    total_count = len(recommendations)
    interacted_count = sum(1 for r in recommendations if r.get('interacted', False))
    applied_count = sum(1 for r in recommendations if r.get('applied', False))
    avg_similarity = sum(r.get('similarity', 0) for r in recommendations) / total_count if total_count > 0 else 0
    
    return jsonify({
        'hasRecommendations': True,
        'totalCount': total_count,
        'interactedCount': interacted_count,
        'appliedCount': applied_count,
        'averageSimilarity': avg_similarity,
        'lastUpdated': stored_recommendations['timestamp'],
        'algorithm': stored_recommendations.get('algorithm', {'version': 'unknown'})
    })

if __name__ == '__main__':
    app.run(debug=True)