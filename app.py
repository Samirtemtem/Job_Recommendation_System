from flask import Flask, request, render_template, jsonify
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import pickle
from pymongo import MongoClient
import logging
import re
from bson import ObjectId

app = Flask(__name__)

# Set up logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

# MongoDB setup
client = MongoClient('mongodb+srv://root:root@cluster0.wa1te.mongodb.net/recruitpro?retryWrites=true&w=majority')
db = client['recruitpro']  # Replace with your actual database name if different

# Collections
users_collection = db['users']
profiles_collection = db['profiles']
jobposts_collection = db['jobposts']
skills_collection = db['skills']
educations_collection = db['educations']
experiences_collection = db['experiences']

logging.info("Loading data from MongoDB collections for Flask app...")

# Load data directly if needed for real-time updates
# Otherwise, we'll use the pickle files generated by main.py
try:
    with open('similarity_matrix.pkl', 'rb') as f:
        similarity_matrix = pickle.load(f)

    with open('candidate_similarity_matrix.pkl', 'rb') as f:
        candidate_similarity_matrix = pickle.load(f)

    with open('label_encoders.pkl', 'rb') as f:
        label_encoders = pickle.load(f)

    with open('jobposts.pkl', 'rb') as f:
        jobposts = pickle.load(f)

    with open('candidates.pkl', 'rb') as f:
        candidates = pickle.load(f)
        
    logging.info("Successfully loaded data from pickle files")
    logging.info(f"Loaded {len(candidates)} candidates and {len(jobposts)} job posts")
    
    # Debug log of first few candidates and their IDs
    if not candidates.empty:
        sample_candidates = candidates.head(3)
        logging.debug(f"Sample candidates:\n{sample_candidates}")
        
        # Log the exact CandidateID values and their data types
        logging.debug("CandidateID details:")
        for idx, candidate_id in enumerate(candidates['CandidateID'].head(5)):
            logging.debug(f"  {idx}: {candidate_id} (type: {type(candidate_id)})")
        
except Exception as e:
    logging.error(f"Error loading data from pickle files: {e}")
    # If pickle files aren't available, we could reload from MongoDB here
    # This is a fallback and would require reimplementing the logic from main.py

# Helper function to normalize ID format
def normalize_id(id_value):
    if id_value is None:
        return None
    return str(id_value).strip()

# Helper function to find candidate by ID with fuzzy matching
def find_candidate_by_id(candidate_id, candidates_df):
    """Find a candidate with exact or partial ID match"""
    # Try exact match first
    exact_matches = candidates_df[candidates_df['CandidateID'] == candidate_id]
    if not exact_matches.empty:
        return exact_matches.index[0], 'exact'
    
    # Convert to string for string operations
    candidate_id_str = str(candidate_id).strip()
    
    # Try ObjectId matching if it looks like an ObjectId
    if re.match(r'^[0-9a-f]{24}$', candidate_id_str):
        # Match against the string representation of ObjectId
        for idx, cid in enumerate(candidates_df['CandidateID']):
            if str(cid).strip() == candidate_id_str:
                return idx, 'objectid_string'
    
    # Try partial match (contained within)
    for idx, cid in enumerate(candidates_df['CandidateID']):
        if candidate_id_str in str(cid):
            return idx, 'partial'
    
    # Try prefix match (starts with)
    for idx, cid in enumerate(candidates_df['CandidateID']):
        if str(cid).startswith(candidate_id_str):
            return idx, 'prefix'
    
    # No match found
    return None, 'no_match'

def hybrid_recommendation(candidate_id, candidates, jobposts, similarity_matrix, candidate_similarity_matrix):
    try:
        # Normalize the candidate ID
        normalized_id = normalize_id(candidate_id)
        logging.debug(f"Searching for candidate with normalized ID: {normalized_id}")
        
        # Try direct index lookup first
        try:
            candidate_idx = candidates[candidates['CandidateID'] == normalized_id].index[0]
            match_type = 'exact'
        except IndexError:
            # If direct lookup fails, try fuzzy matching
            candidate_idx, match_type = find_candidate_by_id(normalized_id, candidates)
            if candidate_idx is None:
                raise IndexError(f"No candidate found with ID {normalized_id} (tried exact, ObjectId, partial, and prefix matching)")
        
        logging.debug(f"Found candidate at index {candidate_idx} using {match_type} matching")
        logging.debug(f"Candidate details: {candidates.iloc[candidate_idx][['CandidateID', 'firstName', 'lastName']] if 'firstName' in candidates.columns else candidates.iloc[candidate_idx]['CandidateID']}")

        # Get top 5 job recommendations
        job_indices = np.argsort(-similarity_matrix[:, candidate_idx])[:5]
        logging.debug(f"Job indices: {job_indices}")
        
        # Debug raw similarity values
        similarity_values = similarity_matrix[:, candidate_idx]
        logging.debug(f"All similarity values for this candidate: min={np.min(similarity_values)}, max={np.max(similarity_values)}, mean={np.mean(similarity_values)}")
        logging.debug(f"Top 5 similarity values: {similarity_values[job_indices]}")
        
        # Create content-based recommendations dataframe
        content_based = jobposts.iloc[job_indices].copy()
        content_based['Similarity'] = similarity_matrix[job_indices, candidate_idx]
        
        # Log a more readable version of the recommendations with percentages
        recommendations_log = content_based.copy()
        recommendations_log['Match Percentage'] = recommendations_log['Similarity'].apply(lambda x: f"{x*100:.2f}%")
        logging.debug(f"Content-based jobs with percentages: \n{recommendations_log[['JobTitle', 'Match Percentage']]}")

        # Job recommendation for other candidates (similar to this candidate)
        # Using the first recommended job
        if len(job_indices) > 0:
            job_id = jobposts.iloc[job_indices[0]]['JobID'] 
            job_idx = jobposts[jobposts['JobID'] == job_id].index[0]
            
            # Find similar candidates for this job
            candidate_indices = np.argsort(-candidate_similarity_matrix[:, job_idx])[:5]
            similar_candidates = candidates.iloc[candidate_indices].copy()
            similar_candidates['Similarity'] = candidate_similarity_matrix[candidate_indices, job_idx]
            
            # Log similar candidates with percentages
            similar_candidates_log = similar_candidates.copy()
            similar_candidates_log['Match Percentage'] = similar_candidates_log['Similarity'].apply(lambda x: f"{x*100:.2f}%")
            logging.debug(f"Similar candidates with percentages: \n{similar_candidates_log[['CandidateID', 'Match Percentage']]}")
        else:
            similar_candidates = pd.DataFrame(columns=['CandidateID', 'Similarity'])
        
        return (
            content_based.sort_values(by='Similarity', ascending=False).reset_index(drop=True),
            similar_candidates.sort_values(by='Similarity', ascending=False).reset_index(drop=True)
        )
    except IndexError as e:
        logging.error(f"No candidate found with ID {candidate_id}. Error: {e}")
        return pd.DataFrame(columns=['JobID', 'JobTitle', 'Similarity']), pd.DataFrame(columns=['CandidateID', 'Similarity'])
    except Exception as e:
        logging.error(f"Error in recommendation: {e}")
        return pd.DataFrame(columns=['JobID', 'JobTitle', 'Similarity']), pd.DataFrame(columns=['CandidateID', 'Similarity'])

@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')

@app.route('/recommend', methods=['POST'])
def recommend_jobs():
    candidate_id = request.form['candidate_id']
    logging.debug("Received request for candidate ID: %s", candidate_id)
    
    try:
        recommended_jobs, similar_candidates = hybrid_recommendation(
            candidate_id, candidates, jobposts, similarity_matrix, candidate_similarity_matrix
        )
        logging.debug("Recommended jobs: \n%s", recommended_jobs)
        logging.debug("Similar candidates: \n%s", similar_candidates)
        
        return render_template(
            'recommendations.html', 
            jobs=recommended_jobs, 
            candidates=similar_candidates
        )
    except Exception as e:
        logging.error(f"Error generating recommendations: {e}")
        return render_template(
            'error.html', 
            error_message=f"Could not generate recommendations: {str(e)}"
        )

# New debug route to display all candidates
@app.route('/debug/candidates', methods=['GET'])
def debug_candidates():
    try:
        # Get all columns for complete debugging
        if candidates.empty:
            return "No candidates found in the database."
        
        # Format the Skills column to be more readable
        candidates_display = candidates.copy()
        if 'Skills' in candidates.columns:
            candidates_display['Skills'] = candidates_display['Skills'].apply(
                lambda skills: ", ".join(skills) if isinstance(skills, list) else str(skills)
            )
        
        # Format IDs to ensure they are displayed correctly
        candidates_display['CandidateID_str'] = candidates_display['CandidateID'].apply(lambda x: str(x))
        
        # Get the ID being searched for from the query parameter
        search_id = request.args.get('id', '')
        
        # If a search ID is provided, highlight matching rows
        if search_id:
            search_results = []
            for idx, row in candidates_display.iterrows():
                candidate_id = str(row['CandidateID'])
                match_type = None
                
                if candidate_id == search_id:
                    match_type = 'exact match'
                elif search_id in candidate_id:
                    match_type = 'partial match'
                elif candidate_id.startswith(search_id):
                    match_type = 'prefix match'
                
                if match_type:
                    search_results.append({
                        'index': idx,
                        'candidate_id': candidate_id,
                        'match_type': match_type,
                        'data': {col: row[col] for col in candidates_display.columns if col != 'CandidateID_str'}
                    })
            
            if search_results:
                search_html = f"<h2>Search Results for ID: {search_id}</h2>"
                for result in search_results:
                    search_html += f"""
                    <div class="card mb-3">
                        <div class="card-header">
                            <strong>Index {result['index']}</strong> - {result['match_type']}
                        </div>
                        <div class="card-body">
                            <p><strong>CandidateID:</strong> {result['candidate_id']}</p>
                            <table class="table table-sm">
                                <tbody>
                    """
                    for key, value in result['data'].items():
                        search_html += f"<tr><td>{key}</td><td>{value}</td></tr>"
                    
                    search_html += "</tbody></table></div></div>"
            else:
                search_html = f"<div class='alert alert-warning'>No matches found for ID: {search_id}</div>"
        else:
            search_html = ""
        
        # Display the first 50 candidates by default for performance
        display_limit = 50
        limited_display = candidates_display.head(display_limit)
        candidates_html = limited_display.to_html(classes='table table-striped table-bordered', index=True)
        
        # Search form for specific ID
        search_form = f"""
        <form method="get" action="/debug/candidates" class="mb-4">
            <div class="input-group">
                <input type="text" name="id" class="form-control" placeholder="Search for candidate ID" value="{search_id}">
                <div class="input-group-append">
                    <button class="btn btn-primary" type="submit">Search</button>
                </div>
            </div>
        </form>
        """
        
        # Create a simple HTML page to display the data
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Candidates Debug</title>
            <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
            <style>
                body {{ padding: 20px; }}
                h1, h2 {{ margin-bottom: 20px; }}
                .container {{ max-width: 100%; }}
                .table {{ margin-top: 20px; font-size: 0.9rem; }}
                .highlight {{ background-color: #ffffcc; }}
                .card {{ margin-bottom: 20px; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>All Candidates (Total: {len(candidates)})</h1>
                <div class="d-flex mb-3">
                    <a href="/" class="btn btn-primary mr-2">Back to Home</a>
                    <a href="/debug/jobposts" class="btn btn-secondary">View Job Posts</a>
                </div>
                
                {search_form}
                
                {search_html}
                
                <h2>Candidate Data (first {display_limit} records)</h2>
                <div class="alert alert-info">
                    <p><strong>Note:</strong> Only showing the first {display_limit} records for performance. Use the search above to find specific candidates.</p>
                </div>
                <div class="table-responsive">
                    {candidates_html}
                </div>
            </div>
        </body>
        </html>
        """
        return html
    except Exception as e:
        return f"Error displaying candidates: {str(e)}"

# Debug route to display all job posts
@app.route('/debug/jobposts', methods=['GET'])
def debug_jobposts():
    try:
        # Get all columns for complete debugging
        if jobposts.empty:
            return "No job posts found in the database."
        
        # Format the Skills column to be more readable
        jobposts_display = jobposts.copy()
        if 'Skills' in jobposts.columns:
            jobposts_display['Skills'] = jobposts_display['Skills'].apply(
                lambda skills: ", ".join(skills) if isinstance(skills, list) else str(skills)
            )
        
        # Display the first 50 jobposts by default for performance
        display_limit = 50
        limited_display = jobposts_display.head(display_limit)
        jobposts_html = limited_display.to_html(classes='table table-striped table-bordered', index=True)
        
        # Create a simple HTML page to display the data
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Job Posts Debug</title>
            <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
            <style>
                body {{ padding: 20px; }}
                h1 {{ margin-bottom: 20px; }}
                .container {{ max-width: 100%; }}
                .table {{ margin-top: 20px; font-size: 0.9rem; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>All Job Posts (Total: {len(jobposts)})</h1>
                <div class="d-flex mb-3">
                    <a href="/" class="btn btn-primary mr-2">Back to Home</a>
                    <a href="/debug/candidates" class="btn btn-secondary">View Candidates</a>
                </div>
                <div class="alert alert-info">
                    <p><strong>Note:</strong> Only showing the first {display_limit} records for performance.</p>
                </div>
                <div class="table-responsive">
                    {jobposts_html}
                </div>
            </div>
        </body>
        </html>
        """
        return html
    except Exception as e:
        return f"Error displaying job posts: {str(e)}"

# Add a new route to analyze skill overlap
@app.route('/debug/skill_analysis', methods=['GET'])
def debug_skill_analysis():
    try:
        if candidates.empty or jobposts.empty:
            return "No data available for skill analysis."
        
        # Extract unique skills from candidates and job posts
        candidate_skills = set()
        for skills in candidates['Skills']:
            if isinstance(skills, list):
                candidate_skills.update(skills)

        jobpost_skills = set()
        for skills in jobposts['Skills']:
            if isinstance(skills, list):
                jobpost_skills.update(skills)
        
        # Find common skills and unique skills
        common_skills = candidate_skills.intersection(jobpost_skills)
        only_in_candidates = candidate_skills - jobpost_skills
        only_in_jobs = jobpost_skills - candidate_skills
        
        # Count skills per candidate and job
        candidate_skill_counts = []
        for i, row in candidates.iterrows():
            skills = row['Skills'] if isinstance(row['Skills'], list) else []
            candidate_skill_counts.append({
                'candidate_id': row['CandidateID'],
                'name': f"{row['firstName']} {row['lastName']}" if 'firstName' in row else str(row['CandidateID']),
                'skill_count': len(skills),
                'skills': ', '.join(skills) if skills else 'None'
            })
        
        job_skill_counts = []
        for i, row in jobposts.iterrows():
            skills = row['Skills'] if isinstance(row['Skills'], list) else []
            job_skill_counts.append({
                'job_id': row['JobID'],
                'title': row['JobTitle'],
                'skill_count': len(skills),
                'skills': ', '.join(skills) if skills else 'None'
            })
        
        # Create HTML for the analysis
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Skill Analysis</title>
            <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
            <style>
                body {{ padding: 20px; }}
                h1, h2, h3 {{ margin-bottom: 20px; }}
                .container {{ max-width: 100%; }}
                .skill-tag {{
                    background-color: #e7f4fd;
                    color: #3498db;
                    padding: 5px 10px;
                    border-radius: 4px;
                    margin-right: 5px;
                    margin-bottom: 5px;
                    display: inline-block;
                }}
                .common-skill {{
                    background-color: #d4edda;
                    color: #155724;
                }}
                .candidate-only-skill {{
                    background-color: #fff3cd;
                    color: #856404;
                }}
                .job-only-skill {{
                    background-color: #f8d7da;
                    color: #721c24;
                }}
                .skill-section {{
                    margin-bottom: 30px;
                    padding: 15px;
                    border-radius: 5px;
                    background-color: #f8f9fa;
                }}
                .table {{ margin-top: 20px; }}
            </style>
        </head>
        <body>
            <div class="container">
                <h1>Skill Analysis</h1>
                <div class="d-flex mb-3">
                    <a href="/" class="btn btn-primary mr-2">Back to Home</a>
                    <a href="/debug/candidates" class="btn btn-outline-secondary mr-2">View Candidates</a>
                    <a href="/debug/jobposts" class="btn btn-outline-secondary">View Job Posts</a>
                </div>
                
                <div class="alert alert-info">
                    <p><strong>Note:</strong> This page analyzes the skill overlap between candidates and job posts.</p>
                </div>
                
                <div class="row">
                    <div class="col-md-6">
                        <div class="card mb-4">
                            <div class="card-header">
                                <h3 class="m-0">Summary</h3>
                            </div>
                            <div class="card-body">
                                <p><strong>Total candidates:</strong> {len(candidates)}</p>
                                <p><strong>Total job posts:</strong> {len(jobposts)}</p>
                                <p><strong>Total unique candidate skills:</strong> {len(candidate_skills)}</p>
                                <p><strong>Total unique job post skills:</strong> {len(jobpost_skills)}</p>
                                <p><strong>Common skills:</strong> {len(common_skills)}</p>
                                <p><strong>Skills only in candidates:</strong> {len(only_in_candidates)}</p>
                                <p><strong>Skills only in jobs:</strong> {len(only_in_jobs)}</p>
                                <p><strong>Skill overlap percentage:</strong> {len(common_skills)/len(candidate_skills.union(jobpost_skills))*100:.1f}%</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="card mb-4">
                            <div class="card-header">
                                <h3 class="m-0">Skill Distribution</h3>
                            </div>
                            <div class="card-body">
                                <div class="skill-section">
                                    <h4>Common Skills ({len(common_skills)})</h4>
                                    {' '.join([f'<span class="skill-tag common-skill">{skill}</span>' for skill in sorted(common_skills)])}
                                </div>
                                
                                <div class="skill-section">
                                    <h4>Skills Only in Candidates ({len(only_in_candidates)})</h4>
                                    {' '.join([f'<span class="skill-tag candidate-only-skill">{skill}</span>' for skill in sorted(only_in_candidates)])}
                                </div>
                                
                                <div class="skill-section">
                                    <h4>Skills Only in Jobs ({len(only_in_jobs)})</h4>
                                    {' '.join([f'<span class="skill-tag job-only-skill">{skill}</span>' for skill in sorted(only_in_jobs)])}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <div class="col-md-6">
                        <div class="card mb-4">
                            <div class="card-header">
                                <h3 class="m-0">Candidates With Fewest Skills</h3>
                            </div>
                            <div class="card-body">
                                <table class="table table-bordered">
                                    <thead>
                                        <tr>
                                            <th>Candidate</th>
                                            <th>Skill Count</th>
                                            <th>Skills</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {''.join([f'<tr><td>{c["name"]}</td><td>{c["skill_count"]}</td><td>{c["skills"]}</td></tr>' for c in sorted(candidate_skill_counts, key=lambda x: x["skill_count"])[:5]])}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="card mb-4">
                            <div class="card-header">
                                <h3 class="m-0">All Job Posts</h3>
                            </div>
                            <div class="card-body">
                                <table class="table table-bordered">
                                    <thead>
                                        <tr>
                                            <th>Job Title</th>
                                            <th>Skill Count</th>
                                            <th>Skills</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {''.join([f'<tr><td>{j["title"]}</td><td>{j["skill_count"]}</td><td>{j["skills"]}</td></tr>' for j in job_skill_counts])}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card mb-4">
                    <div class="card-header">
                        <h3 class="m-0">Recommendation</h3>
                    </div>
                    <div class="card-body">
                        <div class="alert alert-warning">
                            <p><strong>Issue detected:</strong> Low skill overlap between candidates and jobs.</p>
                            <p>To improve matching quality:</p>
                            <ol>
                                <li>Make sure job postings include the same skill terminology as candidate profiles</li>
                                <li>Ensure candidates have their skills properly populated</li>
                                <li>Consider normalizing skill names (e.g., "JavaScript" vs "Javascript")</li>
                                <li>Add more categorical features to improve matching beyond skills</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>
        </body>
        </html>
        """
        return html
    except Exception as e:
        return f"Error analyzing skills: {str(e)}"

if __name__ == '__main__':
    app.run(debug=True)